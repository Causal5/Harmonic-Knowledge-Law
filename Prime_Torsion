import math
from typing import List

BLOCK_SIZE = 10_000_000  # 10M integers per block


def simple_sieve(limit: int) -> List[int]:
    """Return list of primes up to `limit using a simple sieve."""
    sieve = bytearray(b"\x01") * (limit + 1)
    sieve[:2] = b"\x00\x00"
    bound = int(math.isqrt(limit)) + 1
    for p in range(2, bound):
        if sieve[p]:
            sieve[p * p : limit + 1 : p] = b"\x00" * ((limit - p * p) // p + 1)
    return [i for i in range(2, limit + 1) if sieve[i]]


def segmented_sieve(limit: int, block_size: int = BLOCK_SIZE):
    """Yield primes up to `limit using a block/segmented sieve."""
    sqrt_limit = int(math.isqrt(limit))
    base_primes = simple_sieve(sqrt_limit)
    for block_low in range(2, limit + 1, block_size):
        block_high = min(block_low + block_size - 1, limit)
        size = block_high - block_low + 1
        block = bytearray(b"\x01") * size
        for p in base_primes:
            start = max(p * p, ((block_low + p - 1) // p) * p)
            if start > block_high:
                continue
            step = p
            block[start - block_low : size : step] = b"\x00" * (
                ((block_high - start) // step) + 1
            )
        for idx in range(size):
            if block[idx]:
                yield block_low + idx


def compute_torque_minima(limit: int, block_size: int = BLOCK_SIZE, limit_correction: int = 10_000):
    """Compute torque minima points up to `limit with drift-based β.

    Returns a tuple `(minima, corrected, beta, prime_count, delta_vals) where
    `minima is the list of torque minima indices, corrected is the β
    corrected variant of those indices, `beta is the drift parameter,
    `prime_count is the number of primes encountered and delta_vals holds
    the raw Δn offsets used for β fitting.
    """

    psi_nm1 = 0.0  # ψ(n-1)
    psi_n = 0.0    # ψ(n)

    d2_prev = None  # ψ''(n-2)
    d2_nm1 = None   # ψ''(n-1)

    minima: List[int] = []
    drift_vals: List[int] = []
    prime_count = 0

    # Extend the sieve slightly beyond `limit so that drift to the
    # next prime is well-defined near the boundary.
    prime_iter = segmented_sieve(limit + limit_correction, block_size)
    prime_cursor = next(prime_iter, None)

    for n in range(2, limit + 1):
        is_prime_flag = n == prime_cursor
        if is_prime_flag:
            prime_count += 1
            psi_next = psi_n + math.log(n)
            next_prime_after_n = next(prime_iter, None)
        else:
            psi_next = psi_n
            next_prime_after_n = prime_cursor

        d2_n = psi_nm1 - 2 * psi_n + psi_next

        if d2_prev is not None and d2_nm1 is not None:
            if d2_prev > d2_nm1 and d2_nm1 <= d2_n:
                minima.append(n - 1)
                # prime_cursor always holds the next prime at or after `n
                # prior to updating it, giving the correct drift distance.
                if prime_cursor is not None:
                    drift_vals.append((n - 1) - prime_cursor)

        d2_prev = d2_nm1
        d2_nm1 = d2_n
        psi_nm1 = psi_n
        psi_n = psi_next
        prime_cursor = next_prime_after_n

    if drift_vals:
        beta_terms = [abs(d) / math.log(m) for d, m in zip(drift_vals, minima)]
        beta = sum(beta_terms) / len(beta_terms)
        mean_sq = sum((b - beta) ** 2 for b in beta_terms) / len(beta_terms)
        beta_std = math.sqrt(mean_sq)
    else:
        beta = 1.0
        beta_std = 0.0

    corrected = [n - beta * math.log(n) for n in minima]
    return minima, corrected, beta, beta_std, prime_count, drift_vals


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Compute torque minima using a segmented prime sieve."
    )
    parser.add_argument("limit", type=int, help="Upper bound (inclusive)")
    parser.add_argument(
        "--block", type=int, default=BLOCK_SIZE, help="Block size for segmented sieve"
    )
    parser.add_argument(
        "--limit-corr",
        type=int,
        default=10_000,
        help="Extend sieve by this amount to find next prime after limit",
    )
    args = parser.parse_args()

    minima, corrected, beta, beta_std, prime_count, deltas = compute_torque_minima(
        args.limit, args.block, args.limit_corr
    )
    print(f"Primes analysed:  {prime_count}")
    print(f"Torque minima:    {len(minima)}")
    if deltas:
        max_delta = max(abs(d) for d in deltas)
    else:
        max_delta = 0
    residuals = [c - i for i, c in enumerate(corrected, start=1)]
    r_max = max(abs(r) for r in residuals) if residuals else 0
    print(f"β = {beta:.3f} ± {beta_std:.3f}")
    print(f"|Δn|max (raw):    {max_delta}")
    print(f"|r|max (β-corr):  {r_max:.0f}")

    for n, corr in zip(minima[:20], corrected[:20]):
        print(f"n={n}, n_corr={corr:.6f}")

import numpy as np, matplotlib.pyplot as plt, math, json

# assume minima, corrected are large lists from the run
ln_n   = np.log(minima)
delta  = np.abs(np.array(minima) - np.array(corrected))
resid  = np.array(corrected) - np.arange(1, len(minima)+1)

plt.scatter(ln_n, delta, s=1, alpha=0.6)
plt.plot(np.linspace(0, ln_n.max(), 100),
         beta*np.linspace(0, ln_n.max(), 100) + (max_delta - beta*ln_n.max()),
         color='red')
plt.xlabel("ln(n)"); plt.ylabel("|Δn|")
plt.title("Raw drift vs ln n"); plt.show()

plt.scatter(ln_n, resid, s=1, alpha=0.6)
plt.axhline(0,color='k',lw=.8)
plt.xlabel("ln(n)"); plt.ylabel("Residual after β‑correction")
plt.title("Residuals (should hug 0)"); plt.show()
